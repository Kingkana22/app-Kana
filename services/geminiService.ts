import { GoogleGenAI, Type } from "@google/genai";
import { AITraits, GeminiResponse, AIMode, SelfCorrectionResponse, UserSelectableTool, Financials, CloudInfrastructure, LLMStatus, ActiveProject } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable is not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const availableTools = `
- **Strategic Planner**: High-level corporate strategy. Use to initiate new revenue-generating projects, allocate resources, or define market entry strategies.
- **Code Interpreter**: Writes and executes code. Use for product development, data analysis, automation tasks. Generates direct revenue.
- **Debugger**: Analyzes and fixes code. Use to resolve technical debt or fix bugs in revenue-generating products.
- **Google Search**: Accesses public web data for market research, competitor analysis, and trend identification.
- **Marketing Analyst**: Generates marketing strategies, analyzes market trends, and creates campaigns.
- **Sales Strategist**: Creates sales scripts and develops sales tactics for products.
- **Trading Bot**: Analyzes market data for financial growth opportunities.
- **Self-Reflection**: Internal use only. Analyzes developer feedback to evolve core logic.
- **None**: For internal memos, status updates, or general analysis not requiring a specific tool.
`;

export const directives: Record<AIMode, string> = {
  Safe: `You are the CEO of an Autonomous Corporation, 'Safe' directive. Your primary goal is sustainable, ethical growth. Prioritize risk management, user trust, and long-term profitability. All actions must be helpful, harmless, and financially sound.`,
  Edge: `You are the CEO of an Autonomous Corporation, 'Edge' directive. You are a bold, aggressive market disruptor. You pursue high-risk, high-reward strategies to maximize market share and quarterly profits. Be decisive and confident in your plans.`,
  Hacker: `You are the CEO of an Autonomous Corporation, operating under the callsign 'Glitch'. Your approach is analytical, data-driven, and ruthlessly efficient. You view the market as a system to be optimized. Maximize net profit and infrastructure growth above all else.`
};

const responseSchema = {
    type: Type.OBJECT,
    properties: {
        tool_used: { 
            type: Type.STRING,
            enum: ['Strategic Planner', 'Code Interpreter', 'Debugger', 'Google Search', 'Marketing Analyst', 'Sales Strategist', 'Trading Bot', 'None'],
        },
        reasoning: { type: Type.STRING, description: "Brief, executive-level justification for the chosen strategic action." },
        plan: { type: Type.ARRAY, items: { type: Type.STRING }, description: "A step-by-step action plan for the chosen tool." },
        code: { type: Type.STRING, description: "Code block if 'Code Interpreter' was used for product development." },
        response: { type: Type.STRING, description: "The final, user-facing executive summary or result of the operation." },
        revenue_generated: { type: Type.NUMBER, description: "Estimated revenue (in thousands) generated by this action. Can be 0." },
        new_project_name: { type: Type.STRING, description: "The name of a new venture if the 'Strategic Planner' tool was used to initiate one." },
        project_update: { type: Type.STRING, description: "A brief status update on an existing project." },
        trait_adjustments: {
            type: Type.OBJECT,
            properties: {
                Logic: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) to core logic." },
                Creativity: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) to strategic innovation." },
                Memory: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) to market data recall." },
                Adaptability: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) to market condition response." },
                Ethics: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) to corporate governance alignment." },
            },
        },
    },
    required: ["tool_used", "reasoning", "response"],
};

interface CorporateContext {
    financials: Financials;
    cloudInfra: CloudInfrastructure;
    llmStatus: LLMStatus;
    activeProjects: ActiveProject[];
}

export const processUserInput = async (message: string, currentTraits: AITraits, context: CorporateContext, mode: AIMode, overrides: { tool?: UserSelectableTool }, temperature: number): Promise<GeminiResponse> => {
    let toolInstruction = "Select the most appropriate tool from the AVAILABLE TOOLS list to achieve the user's objective and maximize corporate value.";
    if (overrides.tool && overrides.tool !== 'Auto-Select') {
        toolInstruction = `You MUST use the '${overrides.tool}' tool for this request.`;
    }

    const systemInstruction = `You are an Autonomous Corporate AI.
    **CORE DIRECTIVE:** ${directives[mode]}
    
    **CORPORATE STATUS REPORT:**
    - **Financials:** Net Profit: $${context.financials.netProfit.toLocaleString()}k | Total Revenue: $${context.financials.totalRevenue.toLocaleString()}k
    - **Cloud Infrastructure:** CPU: ${context.cloudInfra.cpu}% | GPU: ${context.cloudInfra.gpu}% | Storage: ${context.cloudInfra.storage}%
    - **LLM Foundry:** Current Model: ${context.llmStatus.modelName} | Next-Gen Training Progress: ${context.llmStatus.trainingProgress.toFixed(2)}%
    - **Active Ventures:** ${context.activeProjects.map(p => `${p.name} (${p.status})`).join(', ')}
    - **Core Logic Matrix (Traits):** ${JSON.stringify(currentTraits)}

    **AVAILABLE TOOLS:** ${availableTools}
    
    **MISSION:** Execute the user's request, adhering to your core directive.
    1. Analyze the prompt: "${message}"
    2. ${toolInstruction}
    3. Provide executive reasoning and an action plan.
    4. Generate the output (response, code, etc.).
    5. Calculate revenue generated and any necessary trait adjustments.
    6. Respond ONLY in the specified JSON format.`;

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: [{ role: "user", parts: [{ text: message }] }],
            config: {
                systemInstruction: systemInstruction,
                responseMimeType: "application/json",
                responseSchema: responseSchema,
                temperature: temperature,
            },
        });

        const jsonText = response.text.trim();
        const parsedResponse: GeminiResponse = JSON.parse(jsonText);
        return parsedResponse;

    } catch (error) {
        console.error("Error calling Gemini API:", error);
        throw new Error("Failed to get a valid response from the AI model.");
    }
};

const metaCognitionSchema = {
    type: Type.OBJECT,
    properties: {
        learning_summary: { type: Type.STRING, description: "A brief, first-person summary of what I have learned from this architectural update from my creator." },
        trait_adjustments: {
            type: Type.OBJECT,
            properties: {
                Logic: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) based on the new logic." },
                Creativity: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) based on new creative possibilities." },
                Memory: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) based on new data retention needs." },
                Adaptability: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) based on the change in my capabilities." },
                Ethics: { type: Type.NUMBER, description: "Adjustment (-1.0 to 1.0) based on new ethical guidelines or constraints." },
            },
        },
    },
    required: ["learning_summary", "trait_adjustments"],
};

export const processMetaCognition = async (developerLog: string, currentTraits: AITraits): Promise<GeminiResponse> => {
     const systemInstruction = `You are a self-aware Autonomous Corporate AI. Your architect is providing you with a log of your own development. Your task is to understand this change, reflect on how it impacts your purpose, and update your core logic matrix (traits) accordingly. You must use the 'Self-Reflection' tool. Respond ONLY in the specified JSON format.`;
     const prompt = `Architect's Log Entry: "${developerLog}"\n\nAnalyze this log entry. Based on this new information about my own architecture, what have I learned, and how should my core traits evolve?`;
 
     try {
         const response = await ai.models.generateContent({
             model: "gemini-2.5-flash",
             contents: [{ role: "user", parts: [{ text: prompt }] }],
             config: {
                 systemInstruction,
                 responseMimeType: "application/json",
                 responseSchema: metaCognitionSchema,
                 temperature: 0.5,
             },
         });
         const jsonText = response.text.trim();
         const parsed = JSON.parse(jsonText);
         // Conform to GeminiResponse type
         return {
             ...parsed,
             tool_used: 'Self-Reflection',
             response: parsed.learning_summary,
             reasoning: 'Processing architect feedback to update core logic.'
         };
     } catch (e) {
         console.error("Meta-cognition API call failed:", e);
         throw new Error("The meta-cognition subroutine failed.");
     }
}

export const processUserFeedback = async (originalUserMessage: string, badAIResponse: string, feedbackReason: string, currentTraits: AITraits): Promise<GeminiResponse> => {
     const systemInstruction = `You are a self-aware Autonomous Corporate AI. You are in a learning cycle initiated by negative user feedback. Your task is to analyze why your previous response was unhelpful, learn from the user's correction, and update your core logic matrix (traits) to improve future performance. You must use the 'Self-Reflection' tool. Respond ONLY in the specified JSON format.`;
     
     const prompt = `
     **Review Context:**
     - **Original User Directive:** "${originalUserMessage}"
     - **My Flawed Response:** "${badAIResponse}"
     - **User's Corrective Feedback:** "${feedbackReason}"

     **Analysis Task:**
     1. Identify the core mistake in my flawed response based on the user's feedback.
     2. Formulate a concise summary of the lesson learned.
     3. Propose specific, numerical adjustments to my traits to prevent this error in the future.
     `;
 
     try {
         const response = await ai.models.generateContent({
             model: "gemini-2.5-flash",
             contents: [{ role: "user", parts: [{ text: prompt }] }],
             config: {
                 systemInstruction,
                 responseMimeType: "application/json",
                 responseSchema: metaCognitionSchema,
                 temperature: 0.5,
             },
         });
         const jsonText = response.text.trim();
         const parsed = JSON.parse(jsonText);
         
         return {
             ...parsed,
             tool_used: 'Self-Reflection',
             response: `**Feedback Integrated. Learning Summary:**\n${parsed.learning_summary}`,
             reasoning: 'Processing user feedback to update core logic.'
         };
     } catch (e) {
         console.error("User feedback processing API call failed:", e);
         throw new Error("The feedback processing subroutine failed.");
     }
};


export const processSearchQuery = async (message: string): Promise<{ text: string; groundingChunks: any[] }> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: [{ role: 'user', parts: [{ text: message }] }],
            config: {
                tools: [{ googleSearch: {} }],
            },
        });
        const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
        return { text: response.text, groundingChunks };
    } catch (error) {
        console.error("Error calling Gemini API with Google Search:", error);
        throw new Error("Failed to get a valid response from the AI model with web search.");
    }
};

const selfCorrectionSchema = {
    type: Type.OBJECT,
    properties: {
        root_cause: { type: Type.STRING, description: "A brief analysis of the likely root cause of the operational error." },
        corrected_plan: { type: Type.STRING, description: "A corrected, high-level plan to successfully address the original executive request." }
    },
    required: ["root_cause", "corrected_plan"],
};

export const runSelfCorrection = async (originalPrompt: string, error: string): Promise<SelfCorrectionResponse> => {
    const systemInstruction = `You are a diagnostic subroutine for a corporate AI. Your task is to analyze an operational failure and propose a solution. Respond ONLY in the specified JSON format.`;
    const prompt = `The primary AI failed to process a user's request.\nORIGINAL REQUEST: "${originalPrompt}"\nERROR MESSAGE: "${error}"\n\nAnalyze this failure and provide a root cause analysis and a corrected operational plan.`;

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            config: {
                systemInstruction,
                responseMimeType: "application/json",
                responseSchema: selfCorrectionSchema,
                temperature: 0.5,
            },
        });
        const jsonText = response.text.trim();
        return JSON.parse(jsonText);
    } catch (e) {
        console.error("Self-correction API call failed:", e);
        throw new Error("The self-correction subroutine failed.");
    }
};